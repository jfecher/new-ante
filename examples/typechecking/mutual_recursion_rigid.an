// Mutually recursive definitions which type check when partially annotated despite
// `t != u` and neither ex1a nor ex1b being generalized when ex1b is called within ex1a.
// To do this we need to initialize them with partially generalized types:
//   ex1a: forall t. t -> b1 -> r1
//   ex1b: forall u. u -> b2 -> r2
// Such that b1, b2, r1, and r2 can still be further refined.
ex1a (a: t) b =
    ex1b a b
    0u32

ex1b (a: u) b =
    ex1a a b
    1u32


// Second example
trait T1 a with trait1: fn a -> Unit
trait T2 a with trait2: fn a -> Unit

ex2a (a: t) b =
    ex2b a b
    trait1 a

ex2b (a: u) b =
    ex2c a b
    trait2 a

ex2c (a: v) b =
    ex2a a b

// args: --check --show-types
// expected stdout:
// // id = c1m13_7
// ex1a_c1m13_7 (a_1: t_2) b_3 =
//     ex1b_c1m13_46 a_1 b_3
//     0_U32
// 
// // id = c1m13_46
// ex1b_c1m13_46 (a_1: u_2) b_3 =
//     ex1a_c1m13_7 a_1 b_3
//     1_U32
// 
// // id = c1m13_89
// trait T1_c1m13_89 a_1 with
//     trait1_2: fn a_1 -> Unit_b
// 
// // id = c1m13_89
// trait T2_c1m13_89 a_1 with
//     trait2_2: fn a_1 -> Unit_b
// 
// // id = c1m13_14
// ex2a_c1m13_14 (a_1: t_2) b_3 =
//     ex2b_c1m13_59 a_1 b_3
//     trait1_? a_1
// 
// // id = c1m13_59
// ex2b_c1m13_59 (a_1: u_2) b_3 =
//     ex2c_c1m13_76 a_1 b_3
//     trait2_? a_1
// 
// // id = c1m13_76
// ex2c_c1m13_76 (a_1: v_2) b_3 =
//     ex2a_c1m13_14 a_1 b_3

// expected stderr:
// examples/typechecking/mutual_recursion_rigid.an:22:4	error: `trait1` is not defined, was it a typo?
//     trait1 a
// 
// examples/typechecking/mutual_recursion_rigid.an:26:4	error: `trait2` is not defined, was it a typo?
//     trait2 a

